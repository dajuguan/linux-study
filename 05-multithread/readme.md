# semaphore主要是有任务的时候阻塞
用于线程退出的机制就不合适
## 线程和进程的区别
- 栈里面的数据不共享，其他的全部是和进程共享的
- 线程之间本身内存是共享的(多进程只能通过共享内存啥的)
- 直接调用的是一个函数，不像进程是直接全新启动一个程序

### 线程同步机制
- pthread_join
- 提供条件变量(condition variable)
特有机制: 单词函数、线程本地存储
僵尸线程自己的栈不会释放。

### 可取消线程的资源清理
```

```

## 关键段保护
### 互斥量
PTHREAD_MUTEX_RECURSIVE 递归锁，同一个线程可以锁多次

### 读写锁
pthread_rwlock_rd_lock

### 自旋锁
pthread_spin_init, 可能也就**几个时钟周期**，适用于操作整数啥的，因为把进程挂起再恢复实际上比较耗时，通常用于原子操作(因为有些处理器不支持)。
信号量是一个内核级别的对象，他会有调度，会让线程先停了(基本上能同时跨线程和跨进程的对象都是内核级别的)。

### 原子操作
`<glib.h>`: 支持的类型少，但是很多平台支持。`C11: <stdatomic.h>`:支持类型多，但是兼容性差。
主要用于实现**无锁编程**, compare_and_set,保证这两个指令一定不被打断(如x_86采用XCHG指令实现), 因此要用一个指令实现。
- 操作的类型少
- 目标数
如果`LOCKFREE`为否，则一般是采用自旋锁实现的。

## 同步机制
### 条件变量
- 可广播(只有者一点好处)
- 因为需要一个互斥量写作，用的非常少
### 信号量

## 案例分析: 消息队列
不能直接使用一个链表:
- 比如用户不断发消息，导致直接把系统资源耗尽
```
while(getmsg(&msg)) {
    dispatch(msg)
}
        write_pos    
        ↓
============= loopbuffer
    ↑
    read_pos

post_msg: loopbuffer
sendnotify_msg: linked_list
sendmsg:  需要回执的消息，使用semaphore实现简单的线程同步
```

不断加mutex，代码的可维护性和调试性会非常差。

## 单次函数
比如random的种子

### 线程本地存储(Thread local storage, TLS)
pthread_key_create函数一般使用单次函数创建,一般一个key就够用了，本地存储在栈上。
比如python中会有全局大锁，来处理多线程。
比如每个线程创建私有堆。
`Movebuffer`

## 总结
需要把状态搞清楚，并建立适当合理的多线程架构，适当地进行数据隔离(复杂性也是由于共享引起的), 比如初始化的时候使用指针来访问栈上的数据，就需要同步机制。
在某个执行路径下一定会出错。
