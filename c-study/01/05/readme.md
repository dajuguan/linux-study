# 何谓好的接口？
1. 恰当的抽象
2. 调用者友好
3. 符合惯例，学习成本低
4. 没有过度设计(不炫技)
5. 接口一定要稳定，考虑到将来的应用场景，不去做过多改变

## 例子：从select到epoll
很多接口一开始是这么演进进来的，因为最开始开发者没想到那么多的应用场景

## 两个接口设计原则
1. 完备(Completeness): 不缺东西(如: 增删改查)
2. 自洽(self-consistency): 无逻辑漏洞，自圆其说(定义要清楚)。

### 例子
设计一个独立的网络请求模块设计接口：
1. 接口与具体实现方式，如线程、进程无关
2. 采用异步请求方式，调用者启动网络进程，建立套接字链接，发送请求给网络进程，并可以通过回调接收最终的数据(需要提供轮询的接口)

清晰定义出各个函数、参数的边界；正确使用const等修饰词；

## 完备性的保证
1. 正反: get/set
2. 跟随数据结构: 链表

## 一般性方法和技巧
### 参数及返回值
明确定义返回值的含义；比如int(在32位能用，64位用不了)，可以用size_t

## 模式1：抽象数据类型
1. 隐藏实现细节，为增强、优化和可拓展性打下基础
2. 围绕抽象数据结构设计接口
如int fd = open(),不需要暴漏具体的数据结构
范例: 
- stdio接口
- 抽象读取数据流
- 一般数据类型(鸭子类型): json-c

## 模式2: 抽象算法
1. 围绕抽象算法设计接口，比如不同数据类型的排序算法。通常这种抽象算法都会有一个回调函数
- 不依赖于具体的数据类型
- 不依赖于连续存储的数据类型，如qsort_ex

## 模式3：上下文
通常用来保存当前的设置、状态等信息，通常被设置为句柄handle,隐藏细节的结构指针等；
- 显式上线文
- opengl隐式上下文，一般是解决历史问题，早期没有线程的概念，通过线程局部存储来做到的；

## 模式4: 事件驱动
可以用几种方式：
1. 邮寄消息（可丢失)
2. sendmessage（链表存储)
3. 同步消息
需要把握好粒度，比如wtf的run loop

## 模式5：通用数据结构
比如，树形节点的payload采用指针，并提供设置、访问数据的接口，问题是：
- 内存需要分配多次
- 如果共享数据的话也有问题

解决方法，在用户数据结构中包含节点数据结构，广泛用在使用节点的数据结构，比如链表、树等；
- 迭代宏

## 模式6: 同类聚合
标准IO设计中，文件和内存的操作是一样的，可以进行同类聚合，复用已有的fprint等代码，这样可维护性更好(因为代码量减少了)

- 简化接口设计

## 模式7： 遍历和迭代
- 遍历宏

可维护性，需要多处修改，并且有相同的逻辑的话，就需要抽象为宏/函数之类的代码。
总体目的：想方设法地让编译器来帮我们做一些工作，而非人，尽可能让问题暴露在编译阶段。
比如: sizeof(literal "") ，如果literal传的不是字符，编译器就会直接报错
- 遍历回调
- 迭代器

## 模式8：接口的扩展和兼容性
经常会出现旧的接口设计或考虑不周的情形
二进制兼容性(更好)> 源代码兼容性
- 拓展方法: 预留拓展能力
    - clone3: 通过size判断是老版本，还是旧版本的，相当于加了一个版本号；这种在win32中非常多。
- 拓展方法：新旧接口共存
- 拓展方法：旧接口是新接口的绕转接口
- 拓展方法： 强制使用新接口，旧接口标记为废弃或移除


## Reference
提升三个方面的能力:
- 可维护性：通过编译器来检查
- 接口设计能力：想的越远，那么接口的整个兼容性会更好。要有意识地去想接口设计得是好还是坏。
- 架构设计能力：写完几个模块儿要有一定的架构能力。

- [魏永明C语言最佳实践](https://courses.fmsoft.cn/best-practices-of-c/index.html#/0/1)

