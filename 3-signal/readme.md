## 信号是异步事件
`ls -l`
与异常的区别：
- 信号：一般由操作系统发出，与程序执行是异步的。硬件信号，比如除0；也可以是Ctrl
+c。
- 异常： 一般是在语言层面提供的，是一种可控的同步机制。异常可以基于信号实现，也可以与之完全无关。
## 信号处置
- 有两个信号`SIGKILL`和`SIGSTOP`，不能被忽略和捕获。
- 其他信号可以忽略或被捕获, 每个信号也有默认动作(终止运行)。
## 信号处理函数一般要设计为可重入
不可重入一般是由引入全局变量引起的。非异步非并发也可能出问题。
由于`errno`是每个线程独有的，因此信号处理函数需要进行恢复。
## 打断的系统调用
慢系统调用，如果产生信号，内核会终止调用，以便进程有机会处理信号。被打断后，一般需要重新执行该进程。
## Linux的信号处理
- 信号没有优先级，信号也不会排队(重复)
- 每个进程有两个64位字，分别表示当前挂起的信号及阻塞的信号, 由于是按位的，因此再来一个也不会排队

信号发生时不会立即得到处理:
- 每次从系统调用退出时
- 系统选择改进程执行时

## 线程中的信号处理
POSIX信号是异步发送给整个进程， 所有线程共享同一个设置。
但是每个线程可以由一个掩码，内核决定将信号发生到哪个线程。

## 同步获取信号
- `signalfd`
- `timerfd`: 通过文件描述符获取定时器
可以结合`select`、`epoll`等

## 进程的创建与退出
- `fork`: 共享打开的文件，实现管道等IPC机制的基础； 使用paging on demand 和 copy-on-write方式派生子进程。
- `vfork`: 子进程立即执行。
- `exit()`是C库函数，先调用atexit注册的清除函数，并关闭所有IO流；再调用`_exit`系统调用，把UNIX相关内容如文件描述符、作业控制等；
- 等待子进程退出: `wait()`等待某个子进程退出，`waitpid()`等待指定的子进程退出； 还有这两个函数的拓展调用`wait3(), wait4()`，会返回子进程的资源使用情况。
- 执行程序: `system()`库函数，将完整替代当前进程的数据和代码。这个程序实现非常重!!。
    1. fork(2)
    2. 执行shell
    3. 再执行命令 `execl("/bin/sh", "sh", "-c", command)`



